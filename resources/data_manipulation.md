> Список терминов: [Значения разделенные запятыми (csv)](/resources/glossary.md?id=Значения-разделенные-запятыми-csv), 

# Управление данными в базе

## Создание базы данных в памяти

```shell
sqlite3 :memory: 
```

- «Подключиться» к базе данных в памяти
- Изменения не сохраняются на диск
- Очень полезно для тестирования.

### Создание таблиц

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/22173e8fc5b77d40add8716b72690474/))

```sql
create table job (
    name text not null,
    billable real not null
);
create table work (
    person text not null,
    job text not null
);
```

- `create table имя таблицы`, за которым следует список столбцов в скобках
- Каждый столбец задаётся именем, типом данных и необязательной дополнительной информацией.
- Например ограничение, `not null` предотвращает добавление нулей в столбец.
- Указание схемы в SQLite не является стандартом
- SQLite добавил несколько вещей
  - create if not exists
  - ключевые слова в верхнем регистре (SQL нечувствителен к регистру)


### Вставка данных

В SQL для добавления данных в таблицу используется оператор `insert into`. Сначала указывается имя таблицы, затем в круглых скобках — список столбцов, в которые будут добавлены данные (этот список можно опустить, если значения соответствуют порядку всех столбцов), после чего идет ключевое слово values и перечисление значений. При этом можно вставить несколько строк, разделяя наборы значений запятыми. 

Например, если нужно добавить записи в таблицу job, где есть столбцы name и billable, запрос будет выглядеть так:

```sql
insert into job (name, billable) 
values
    ('Калибровка', 1.5),
    ('Очистка', 0.5);

-- вставка без указания имён столбцов
insert into work 
values
    ('Иван', 'Калибровка'),
    ('Иван', 'Очистка'),
    ('Иван', 'Сортировка'),
    ('Евгений',  'Очистка'),
    ('Евгений',  'Сортировка'),
    ('Вячеслав', 'Сортировка');

select * from job; 

select * from work;
```
([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/fc5132b1f8e993fd1eb0e46815a5f21b/))

```
|   name     | billable |
|------------|----------|
| Калибровка | 1.5      |
| Очистка    | 0.5      |


| person   | job        |
|----------|------------|
| Иван     | Калибровка |
| Иван     | Очистка    |
| Иван     | Сортировка |
| Евгений  | Очистка    |
| Евгений  | Сортировка |
| Вячеслав | Сортировка |
```
- Не используйте SELECT *, за исключением случаев, когда необходимо получить обзор всех данных.

#### Упражнение

1. Используя базу данных в памяти, создайте таблицу под названием `notes` с двумя текстовыми столбцами `author` и `note`, а затем добавьте три или четыре строки. Используйте запрос, чтобы проверить, что заметки сохранены и что вы можете (например) выбрать их по имени автора.
2. Что произойдет, если вы попытаетесь вставить в заметки слишком много или слишком мало значений? Что произойдет, если в поле `note` вместо строки вставить число?

### Обновление записей

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/bcb9b1af1af692f45d6003cd5257c911/))

```sql
update work
set person = 'Слава'
where person = 'Вячеслав';
```
```
| person  | job        |
|---------|------------|
| Иван    | Калибровка |
| Иван    | Очистка    |
| Иван    | Сортировка |
| Евгений | Очистка    |
| Евгений | Сортировка |
| Слава   | Сортировка |
```

> [!WARNING]
> При обновлении записей в таблице всегда указывайте условие `where` в протоимвном случае вы обновите все записи в таблице

### Удаление записей

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/66972881c02215d277100da1ec9e2e69/))

```sql
delete from work
where person = 'Слава';

select * from work;
```
```
| person  | job        |
|---------|------------|
| Иван    | Калибровка |
| Иван    | Очистка    |
| Иван    | Сортировка |
| Евгений | Очистка    |
| Евгений | Сортировка |
```

> [!WARNING]
> И снова, при удалении записей в таблице всегда указывайте условие `where`

#### Упражнение

1. Что произойдет, если вы попытаетесь удалить несуществующие строки (например, все записи в работе, относящиеся к Елене)?


### Восстановление базы данных

```sql
create table backup (
    person text not null,
    job text not null
);

insert into backup
select
    person,
    job
from work
where person = 'Слава';

delete from work
where person = 'Слава';

select * from backup;
```
```
| person | job        |
|--------|------------|
| Слава  | Сортировка |
```

- Далее мы рассмотрим еще одну стратегию основанную на [tombstone](glossary.md#надгробный-камень-tombstone)

#### Упражнение

Сохранение и восстановление данных в виде текста:

1. Воссоздайте таблицу примечаний в базе данных в памяти, а затем используйте команды SQLite .output и .dump, чтобы сохранить базу данных в файл с именем Notes.sql. Проверьте содержимое этого файла: как хранились ваши данные?
2. Запустите новый сеанс SQLite и загрузите Notes.sql с помощью команды .read. Проверьте базу данных с помощью .schema и выберите *: все ли так, как вы ожидали?

Сохранение и восстановление данных в двоичном формате:

1. Снова создайте таблицу примечаний в базе данных в памяти и используйте команду SQLite .backup, чтобы сохранить ее в файл с именем Notes.db. Проверьте этот файл с помощью od -c Notes.db или текстового редактора, который может обрабатывать двоичные данные: как хранились ваши данные?
2. Запустите новый сеанс SQLite и загрузите Notes.db с помощью команды .restore. Проверьте базу данных с помощью .schema и выберите *: все ли так, как вы ожидали?

### Проверка знаний

<img src="./assets/core_datamod_concept_map.svg" alt="Описание" style="max-width:100%; height:auto;">

## Создание новых таблиц из старых

```sql
create table new_work (
    person_id integer not null,
    job_id integer not null,
    foreign key (person_id) references person (ident),
    foreign key (job_id) references job (ident)
);

insert into new_work
select
    person.ident as person_id,
    job.ident as job_id
from person 
inner join work on person.name = work.person
inner join job on job.name = work.job;

select * from new_work;
```
```
| person_id | job_id |
|-----------|--------|
| 1         | 1      |
| 1         | 2      |
| 2         | 2      |
```
1. `new_work` - это новая таблица созданная на основе старой
2. Каждый столбец ссылается на запись в какой-либо другой таблице.

## Удаление таблиц

```sql
drop table work;

alter table new_work rename to work;

create table job (
    ident integer primary key autoincrement,
    name text not null,
    billable real not null
);

create table person (
    ident integer primary key autoincrement,
    name text not null
);

create table IF NOT EXISTS "work" (
    person_id integer not null,
    job_id integer not null,
    foreign key(person_id) references person(ident),
    foreign key(job_id) references job(ident)
);
```
1. Удалите старую таблицу и переименуйте новую, чтобы она заняла ее место.
2. Пожалуйста, сначала сделайте резервную копию ваших данных
3. Не забывайте про условие `IF NOT EXISTS`

### Упражнение

1. Реорганизуйте базу данных пингвинов:
    1. Сделайте копию файла penguins.db, чтобы ваши изменения не повлияли на оригинал.
    2. Напишите скрипт SQL, который реорганизует данные в три таблицы: по одной для каждого острова.
    3. Почему такая организация данных — плохая идея?

2. Такие инструменты, как [Sqitch](https://sqitch.org), могут управлять изменениями в схемах и данных базы данных, чтобы их можно было сохранить в системе контроля версий и откатить в случае неудачи. Переведите изменения, внесенные приведенными выше скриптами, в Sqitch. Примечание: это упражнение может занять час или больше.

### Системные таблицы

```sql
select * from sqlite_sequence;
```
```
| name   | seq |
|--------|-----|
| person | 3   |
```

1. Порядковые номера не сбрасываются при удалении строк.
2. Частично для того, чтобы их можно было использовать в качестве первичных ключей.

#### Упражнение

Можете ли вы изменить значения, хранящиеся в sqlite_sequence? В частности, можете ли вы сбросить значения, чтобы снова генерировались те же порядковые номера?

### Изменение таблиц

```sql
-- добавляем колонку к таблице  
alter table job
add ident integer not null default -1; -- не пустая, знечение по умолчанию -1 

-- обновляем данные в таблице
update job
set ident = 1
where name = 'Калибровка';

update job
set ident = 2
where name = 'Очистка';

-- проверяем результат
select * from job;
```
```
| name       | billable | ident |
|------------|----------|-------|
| Калибровка | 1.5      | 1     |
| Очистка    | 0.5      | 2     |
```

1. Добавить столбец постфактум.
2. Поскольку оно не может быть нулевым, мы должны указать значение по умолчанию.
3. Хочется сделать его первичным ключом, но SQLite не позволяет этого сделать постфактум.
4. Затем используйте обновление для изменения существующих записей.
5. Можно изменить любое количество записей одновременно
6. Так что будьте осторожны с условием `where`

## Индексы

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/fbe5b2d4189e05d804bd58a4d422fec1/))

Индекс - объект базы данных, создаваемый с целью повышения производительности поиска данных.
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени.
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы, таким образом, позволяет быстрее находить строки, удовлетворяющие критерию поиска.
Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.

Посмотрим как выполняется запрос к базе данных. Воспользуемся для этого командой `explain query plan`:

```sql
explain query plan
select *
from penguins
where island = 'Biscoe';
```
Для выполнения такого запроса без индекса СУБД должна проверить значение в поле `island` в каждой строке таблицы (этот механизм известен как «полный перебор» или «полное сканирование таблицы» (`full scan`)).

```
| id | parent | notused | detail              |
|----|--------|---------|---------------------|
| 2  | 0      | 0       | SCAN TABLE penguins |
```

### Создание индекса

```sql
create index island_ix on penguins(island);

explain query plan
select *
from penguins
where island = 'Biscoe';
```
```
| id | parent | notused | detail                                                 |
|----|--------|---------|--------------------------------------------------------|
| 3  | 0      | 0       | SEARCH TABLE penguins USING INDEX island_ix (island=?) |
```

Можно убедиться что план выполнения запроса изменился. Вместо полного перебора `SCAN TABLE` - поиск по индексу `SEARCH TABLE penguins USING INDEX`,  что в случае больших таблиц даёт существенный пророст призводитеьности.

### Ограниченная применимость индекса

```sql
explain query plan
select *
from penguins
where island != 'Biscoe';
```
```
| id | parent | notused | detail              |
|----|--------|---------|---------------------|
| 2  | 0      | 0       | SCAN TABLE penguins |
```

Этот запрос должен нам найти всех пингвинов, кроме тех что проживают на острове 'Biscoe', однако не смотря на то что по столбцу `island` есть индекс, СУБД всё равно будет использовать полный перебор таблицы.
Использование неравенства в условии поиска исключает для СУБД возможность использования поиска по B-дереву.
Если запросы такого типа критичны для вас, то задача может быть решена созданием специальных (функциональных) индексов. Так как не все СУБД поддерживают такой функционал мы не будем углубятся здесь в эту тему.

### Удаление индекса

```sql
drop index island_ix;
```

#### Упражнения

1. Создайте индекс в таблице `penguins` над столбцами `species` и `sex`. 
2. Какой запрос позволит вам воспользоваться преимуществами этого индекса?
3. Удалите созданный вами индекс.

### Закрепление

- Индекс — это вспомогательная структура данных, обеспечивающая более быстрый доступ к записям.
- Занимает место на диске и замедляет операции вставки (`insert`) и изменения данных (`update`), взамен индекс может значительно ускорять операции поиска данных в таблице (`select`).
- Следует следить за использованием индексов и удалять ненужные.
- Индексы могут создаваться и удаляться в любое время.


## Первичный ключ (primary key)

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/fdc77f8d8b8c45b4275a88250491f395/))

1. Можно использовать любое поле (или комбинацию полей) в таблице в качестве первичного ключа, если значения уникальны для каждой записи.
2. Уникально идентифицирует конкретную запись в конкретной таблице.

```sql
-- создаём таблицу
create table lab_equipment (
    -- определяем поля
    size  decimal not null,
    color text not null,
    num   integer not null,
    -- создаём первичный ключ на основе полей size и color
    primary key (size, color)
);

-- вставляем записи в таблицу
insert into lab_equipment values
    (1.5, 'blue', 2),
    (1.5, 'green', 1),
    (2.5, 'blue', 1);

-- проверяем результат
select * from lab_equipment;
```
```
| size | color | num |
|------|-------|-----|
| 1.5  | blue  | 2   |
| 1.5  | green | 1   |
| 2.5  | blue  | 1   |
```
```sql
-- пробуем вставить запись со значением первичного ключа уже существующего в таблице
insert into lab_equipment values
    (1.5, 'green', 2);
```

Закономерно получаем ошибку!

```
UNIQUE constraint failed: lab_equipment.size, lab_equipment.color
```

#### Упражнения

1. Есть ли у таблицы `penguins` первичный ключ? Если да, то что это? А как насчет таблиц `work` и `job`?


### Автоинкремент и первичные ключи

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/44784ebcf722e3a8de6c89f58db7a88a/))

```sql
-- создаём таблицу
create table person (
    ident integer primary key autoincrement, -- определяем поле как первичный ключ и автоинкремент
    name text not null
);

-- вставляем записи в таблицу
insert into person values
    (null, 'Иван'),
    (null, 'Евгений'),
    (null, 'Слава');

-- проверяем результат
select * from person;
```
Поле ident автоматически получает инкрементальные значения
```
| ident | name    |
|-------|---------|
| 1     | Иван    |
| 2     | Евгений |
| 3     | Слава   |
```
```sql
-- пробуем вставить запись с уже существующим значением инкремента
insert into person values (1, 'prevented');
```
И снова получаем ошибку!
```
UNIQUE constraint failed: person.ident
```
1. Автоинкремент автоматически увеличивается для каждой вставленной записи
2. Обычно это поле используется в качестве первичного ключа, уникального для каждой записи.
3. Если Слава снова сменит имя, нам останется изменить только один факт в базе данных.
4. Недостаток: ручные запросы труднее читать (кто такой человек 17?)


## Добавляем ограничения

```sql
-- создаём таблицу с ограничением
create table job (
    name text not null,
    billable real not null,
    check (billable > 0.0)
);

-- вносим данные
insert into job values ('Калибровка', 1.5);
insert into job values ('Очистка', -0.5);

-- проверяем результат
select * from job;
```

```
CHECK constraint failed: billable > 0.0

| name       | billable |
|------------|----------|
| Калибровка | 1.5      |
```
- получаем ошибку
- строка не прошедшая проверку не внесена в таблицу

- Функция `check` добавляет ограничение в таблицу:
    - Должна выдавать результат типа `boolean`.
    - Выполняется каждый раз, когда значения добавляются или изменяются.
    - Но изменения, внесенные до ошибки, вступают в силу.

#### Упражнение

1. Перепишите определение таблицы `penguins`, добавив следующие ограничения:
    - `body_mass_g` должен быть неотрицательным.
    - `island` должен быть одним из "Biscoe", "Dream" или "Torgersen". (Подсказка: оператор `in` здесь будет полезен.)

## Внешние ключи

## Триггеры

    - Триггер — это автоматически выполняемый код, который реагирует на изменения в базе данных.
    - Триггеры могут выполняться до или после операции.
    - Триггеры могут выполняться на вставку, обновление или удаление.
    - Триггеры могут быть использованы для проверки данных, обновления связанных таблиц и многого другого.
    - Триггеры могут быть отключены, включены или удалены.
    - Триггеры могут быть созданы в любой момент, в любой таблице и в любой базе данных.
    - Триггеры могут быть созданы в любой СУБД, но синтаксис может отличаться.
    - Внутри триггера можнообращаться к старой и новой версии записи как old.column и new.column.

### Создание триггеров

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/b113b9038a7bbe90e5a05be8a31158e0/))

```sql
-- создаем таблицу учёта рабочего времени
create table job (
    person text not null,
    reported real not null check (reported >= 0.0)
);

-- создаем таблицу с общим временем работы
create table total (
    person text unique not null,
    hours real
);

-- создаем триггер для обновления таблицы `total`
create trigger total_trigger
before insert -- триггер срабатывает перед вставкой
on job -- в таблицу job
begin
    -- код который выполняется при срабатывании триггера
    insert into total values
        (new.person, new.reported) -- new - обозначает значения из вставляемой строки
    on conflict(person) do update set hours = hours + new.reported;
end;
```

### Срабатывание триггера
```sql
-- вносим данные
insert into job values
    ('Олег', 1.5),
    ('Сергей', 0.5),
    ('Олег', 1.0);

-- проверяем результат
select * from job;

select * from total;
```
```
| person | reported |
|--------|----------|
| Олег   | 1.5      |
| Сергей | 0.5      |
| Олег   | 1.0      |

| person | hours |
|--------|-------|
| Олег   | 2.5   |
| Сергей | 0.5   |
```
- данные в таблице `total` обновились автоматически.

### Триггер не срабатывает

```sql
-- вносим данные
insert into job values
    ('Олег', 1.0),
    ('Сергей', -1.0);

-- проверяем результат
select * from job;

select * from total;
```
```
CHECK constraint failed: reported >= 0.0 (19)

| person | hours |
|--------|-------|
| Олег   | 0.0   |
| Сергей | 0.0   |
```
- данные не внесены в таблицу `total` из-за нарушения ограничения.

#### Упражнение

Используя базу данных пингвинов:
1. Создайте таблицу с именем `species` со столбцами `name` и `count`. Столбец `name` должен быть уникальным. Затем создайте триггер, который обновляет таблицу `species` каждый раз, когда в таблицу `penguins` добавляется новая запись. Триггер должен увеличивать счетчик для соответствующего вида пингвина.
2. Правильно ли ведет себя ваше решение, когда несколько пингвинов добавляются одним оператором вставки?
