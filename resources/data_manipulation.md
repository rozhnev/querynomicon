# Управление данными в базе

## Создание новых таблиц из старых

```sql
create table new_work (
    person_id integer not null,
    job_id integer not null,
    foreign key (person_id) references person (ident),
    foreign key (job_id) references job (ident)
);

insert into new_work
select
    person.ident as person_id,
    job.ident as job_id
from person 
inner join work on person.name = work.person
inner join job on job.name = work.job;

select * from new_work;
```
```
| person_id | job_id |
|-----------|--------|
| 1         | 1      |
| 1         | 2      |
| 2         | 2      |
```
1. `new_work` - это новая таблица созданная на основе старой
2. Каждый столбец ссылается на запись в какой-либо другой таблице.

## Удаление таблиц

```sql
drop table work;

alter table new_work rename to work;

create table job (
    ident integer primary key autoincrement,
    name text not null,
    billable real not null
);

create table person (
    ident integer primary key autoincrement,
    name text not null
);

create table IF NOT EXISTS "work" (
    person_id integer not null,
    job_id integer not null,
    foreign key(person_id) references person(ident),
    foreign key(job_id) references job(ident)
);
```
1. Удалите старую таблицу и переименуйте новую, чтобы она заняла ее место.
2. Пожалуйста, сначала сделайте резервную копию ваших данных
3. Не забывайте про условие `IF NOT EXISTS`

### Упражнение

1. Реорганизуйте базу данных пингвинов:
    1. Сделайте копию файла penguins.db, чтобы ваши изменения не повлияли на оригинал.
    2. Напишите скрипт SQL, который реорганизует данные в три таблицы: по одной для каждого острова.
    3. Почему такая организация данных — плохая идея?

2. Такие инструменты, как [Sqitch](https://sqitch.org), могут управлять изменениями в схемах и данных базы данных, чтобы их можно было сохранить в системе контроля версий и откатить в случае неудачи. Переведите изменения, внесенные приведенными выше скриптами, в Sqitch. Примечание: это упражнение может занять час или больше.

## Индексы

([выполнить sql онлайн](https://sqlize.online/sql/sqlite3_data/fbe5b2d4189e05d804bd58a4d422fec1/))

Индекс - объект базы данных, создаваемый с целью повышения производительности поиска данных.
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке, и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени.
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы, таким образом, позволяет быстрее находить строки, удовлетворяющие критерию поиска.
Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру, оптимизированную под поиск — например, сбалансированного дерева.

Посмотрим как выполняется запрос к базе данных. Воспользуемся для этого командой `explain query plan`:

```sql
explain query plan
select *
from penguins
where island = 'Biscoe';
```
Для выполнения такого запроса без индекса СУБД должна проверить значение в поле `island` в каждой строке таблицы (этот механизм известен как «полный перебор» или «полное сканирование таблицы» (`full scan`)).

```
| id | parent | notused | detail              |
|----|--------|---------|---------------------|
| 2  | 0      | 0       | SCAN TABLE penguins |
```

### Создание индекса

```sql
create index island_ix on penguins(island);

explain query plan
select *
from penguins
where island = 'Biscoe';
```
```
| id | parent | notused | detail                                                 |
|----|--------|---------|--------------------------------------------------------|
| 3  | 0      | 0       | SEARCH TABLE penguins USING INDEX island_ix (island=?) |
```

Можно убедиться что план выполнения запроса изменился. Вместо полного перебора `SCAN TABLE` - поиск по индексу `SEARCH TABLE penguins USING INDEX`,  что в случае больших таблиц даёт существенный пророст призводитеьности.

### Ограниченная применимость индекса

```sql
explain query plan
select *
from penguins
where island != 'Biscoe';
```
```
| id | parent | notused | detail              |
|----|--------|---------|---------------------|
| 2  | 0      | 0       | SCAN TABLE penguins |
```

Этот запрос должен нам найти всех пингвинов, кроме тех что проживают на острове 'Biscoe', однако не смотря на то что по столбцу `island` есть индекс, СУБД всё равно будет использовать полный перебор таблицы.
Использование неравенства в условии поиска исключает для СУБД возможность использования поиска по B-дереву.
Если запросы такого типа критичны для вас, то задача может быть решена созданием специальных (функциональных) индексов. Так как не все СУБД поддерживают такой функционал мы не будем углубятся здесь в эту тему.

### Удаление индекса

```sql
drop index island_ix;
```

#### Упражнения

1. Создайте индекс в таблице `penguins` над столбцами `species` и `sex`. 
2. Какой запрос позволит вам воспользоваться преимуществами этого индекса?
3. Удалите созданный вами индекс.

### Закрепление

- Индекс — это вспомогательная структура данных, обеспечивающая более быстрый доступ к записям.
- Занимает место на диске и замедляет операции вставки (`insert`) и изменения данных (`update`), взамен индекс может значительно ускорять операции поиска данных в таблице (`select`).
- Следует следить за использованием индексов и удалять ненужные.
- Индексы могут создаваться и удаляться в любое время.


## Внешние ключи