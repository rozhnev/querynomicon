# Управление данными в базе

## Создание новых таблиц из старых

```sql
create table new_work (
    person_id integer not null,
    job_id integer not null,
    foreign key (person_id) references person (ident),
    foreign key (job_id) references job (ident)
);

insert into new_work
select
    person.ident as person_id,
    job.ident as job_id
from person 
inner join work on person.name = work.person
inner join job on job.name = work.job;

select * from new_work;
```
```
| person_id | job_id |
|-----------|--------|
| 1         | 1      |
| 1         | 2      |
| 2         | 2      |
```
1. `new_work` - это новая таблица созданная на основе старой
2. Каждый столбец ссылается на запись в какой-либо другой таблице.

## Удаление таблиц

```sql
drop table work;

alter table new_work rename to work;

create table job (
    ident integer primary key autoincrement,
    name text not null,
    billable real not null
);

create table person (
    ident integer primary key autoincrement,
    name text not null
);

create table IF NOT EXISTS "work" (
    person_id integer not null,
    job_id integer not null,
    foreign key(person_id) references person(ident),
    foreign key(job_id) references job(ident)
);
```
1. Удалите старую таблицу и переименуйте новую, чтобы она заняла ее место.
2. Пожалуйста, сначала сделайте резервную копию ваших данных
3. Не забывайте про условие `IF NOT EXISTS`

### Упражнение

1. Реорганизуйте базу данных пингвинов:
    1. Сделайте копию файла penguins.db, чтобы ваши изменения не повлияли на оригинал.
    2. Напишите скрипт SQL, который реорганизует данные в три таблицы: по одной для каждого острова.
    3. Почему такая организация данных — плохая идея?

2. Такие инструменты, как [Sqitch](https://sqitch.org), могут управлять изменениями в схемах и данных базы данных, чтобы их можно было сохранить в системе контроля версий и откатить в случае неудачи. Переведите изменения, внесенные приведенными выше скриптами, в Sqitch. Примечание: это упражнение может занять час или больше.

## Индексы

Это - объект базы данных, создаваемый с целью повышения производительности поиска данных.
Таблицы в базе данных могут иметь большое количество строк, которые хранятся в произвольном порядке,
и их поиск по заданному критерию путём последовательного просмотра таблицы строка за строкой может занимать много времени.
Индекс формируется из значений одного или нескольких столбцов таблицы и указателей на соответствующие строки таблицы и,
таким образом, позволяет искать строки, удовлетворяющие критерию поиска.
Ускорение работы с использованием индексов достигается в первую очередь за счёт того, что индекс имеет структуру,
оптимизированную под поиск — например, сбалансированного дерева.

### Создание индекса

```sql
explain query plan
SELECT first_name 
  FROM people 
 WHERE last_name = 'John Doe';
```
```
QUERY PLAN
`--SCAN plate USING COVERING INDEX sqlite_autoindex_people_1
```

Для выполнения такого запроса без индекса СУБД должна проверить поле `last_name` в каждой строке таблицы 
(этот механизм известен как «полный перебор» или «полное сканирование таблицы», в плане может отображаться словом NATURAL).
При использовании индекса СУБД просто проходит по B-дереву, пока не найдёт записи, `John Doe`.
Такой проход требует гораздо меньше ресурсов, чем полный перебор таблицы.

```sql
create index customers_file on customers(email_address);

explain query plan
SELECT email_address 
  FROM customers 
 WHERE email_address 
  LIKE '%@yahoo.com';
```
```
QUERY PLAN
`--SCAN plate USING COVERING INDEX customers_file
```
Этот запрос должен нам найти всех клиентов, у которых е-мейл заканчивается на @yahoo.com,
однако даже если по столбцу email_address есть индекс,
СУБД всё равно будет использовать полный перебор таблицы.
Это связано с тем, что индексы строятся в предположении,
что слова/символы идут слева направо. Использование символа подстановки в начале условия поиска исключает для СУБД возможность использования поиска по B-дереву.
Во многих СУБД эта проблема может быть решена созданием дополнительного индекса по выражению reverse(email_address) и формированием запроса вида:

1. Индекс — это вспомогательная структура данных, обеспечивающая более быстрый доступ к записям.
2. Требует место на диске
3. В отличие от первичных ключей, SQLite поддерживает определение индексов постфактум.


## Внешние ключи